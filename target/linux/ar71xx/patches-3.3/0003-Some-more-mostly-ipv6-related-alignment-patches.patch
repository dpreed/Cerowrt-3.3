From 0197320ff591e693922349a660eca759767de399 Mon Sep 17 00:00:00 2001
From: Dave Taht <dave.taht@bufferbloat.net>
Date: Thu, 12 Apr 2012 10:24:51 -0700
Subject: [PATCH 3/3] Some more (mostly ipv6) related alignment patches

Hopefully this will nail all but two of the remaining
traps in the hot path.
---
 include/linux/in6.h    |    2 +-
 include/linux/tcp.h    |    3 ++-
 include/net/addrconf.h |   25 ++++++++++++++++---------
 include/net/ipv6.h     |   28 ++++++++++++++++++++--------
 net/ipv4/tcp.c         |    2 +-
 net/xfrm/xfrm_input.c  |    8 +++++---
 6 files changed, 45 insertions(+), 23 deletions(-)

diff --git a/include/linux/in6.h b/include/linux/in6.h
index 097a34b..1cf8a26 100644
--- a/include/linux/in6.h
+++ b/include/linux/in6.h
@@ -36,7 +36,7 @@ struct in6_addr {
 #define s6_addr			in6_u.u6_addr8
 #define s6_addr16		in6_u.u6_addr16
 #define s6_addr32		in6_u.u6_addr32
-};
+} __packed;
 
 /* IPv6 Wildcard Address (::) and Loopback Address (::1) defined in RFC2553
  * NOTE: Be aware the IN6ADDR_* constants and in6addr_* externals are defined
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index e48536a..7c3bf08 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -66,7 +66,8 @@ union tcp_word_hdr {
 	__be32 		  words[5];
 }; 
 
-#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+#define tcp_flag_word2(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+#define tcp_flag_word(tp) ( __get_unaligned_cpu32(&(((union tcp_word_hdr *)(tp))->words [3])))
 
 enum { 
 	TCP_FLAG_CWR = __cpu_to_be32(0x00800000),
diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f68dce2..84e5a26 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -251,31 +251,38 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 	ipv6_addr_set(solicited,
 		      htonl(0xFF020000), 0,
 		      htonl(0x1),
-		      htonl(0xFF000000) | addr->s6_addr32[3]);
+		      htonl(0xFF000000) | 
+		      __get_unaligned_cpu32(&addr->s6_addr32[3]));
 }
 
 static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);
+  return (__get_unaligned_cpu32(&addr->s6_addr32[0]) &
+	  htonl(0xFF000000)) == htonl(0xFF000000);
 }
 
 static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
-	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
-		addr->s6_addr32[1] | addr->s6_addr32[2] |
-		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0;
+  return ((__get_unaligned_cpu32(&addr->s6_addr32[0]) ^ htonl(0xff020000)) |
+	  __get_unaligned_cpu32(&addr->s6_addr32[1]) |
+	  __get_unaligned_cpu32(&addr->s6_addr32[2]) |
+	  (__get_unaligned_cpu32(&addr->s6_addr32[3]) ^
+	  htonl(0x00000001))) == 0;
 }
 
 static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
-	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
-		addr->s6_addr32[1] | addr->s6_addr32[2] |
-		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;
+  return ((__get_unaligned_cpu32(&addr->s6_addr32[0]) ^ htonl(0xff020000)) |
+	  __get_unaligned_cpu32(&addr->s6_addr32[1]) |
+	  __get_unaligned_cpu32(&addr->s6_addr32[2]) |
+	  (__get_unaligned_cpu32(&addr->s6_addr32[3]) ^
+	  htonl(0x00000002))) == 0;
 }
 
 static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);
+	return (__get_unaligned_cpu32(&addr->s6_addr32[2]) |
+		htonl(0x02000000)) == htonl(0x02005EFE);
 }
 
 #ifdef CONFIG_PROC_FS
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index e4170a2..43603ee 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -303,10 +303,18 @@ static inline int
 ipv6_masked_addr_cmp(const struct in6_addr *a1, const struct in6_addr *m,
 		     const struct in6_addr *a2)
 {
-	return !!(((a1->s6_addr32[0] ^ a2->s6_addr32[0]) & m->s6_addr32[0]) |
-		  ((a1->s6_addr32[1] ^ a2->s6_addr32[1]) & m->s6_addr32[1]) |
-		  ((a1->s6_addr32[2] ^ a2->s6_addr32[2]) & m->s6_addr32[2]) |
-		  ((a1->s6_addr32[3] ^ a2->s6_addr32[3]) & m->s6_addr32[3]));
+  return !!(((a1->s6_addr32[0] ^ 
+	      __get_unaligned_cpu32(&a2->s6_addr32[0])) &
+	      m->s6_addr32[0]) |
+	    ((a1->s6_addr32[1] ^
+	      __get_unaligned_cpu32(&a2->s6_addr32[1])) &
+	      m->s6_addr32[1]) |
+	    ((a1->s6_addr32[2] ^
+	      __get_unaligned_cpu32(&a2->s6_addr32[2])) &
+	      m->s6_addr32[2]) |
+	    ((a1->s6_addr32[3] ^
+	      __get_unaligned_cpu32(&a2->s6_addr32[3])) &
+	      m->s6_addr32[3]));
 }
 
 static inline void ipv6_addr_prefix(struct in6_addr *pfx, 
@@ -336,10 +344,14 @@ static inline void ipv6_addr_set(struct in6_addr *addr,
 static inline int ipv6_addr_equal(const struct in6_addr *a1,
 				  const struct in6_addr *a2)
 {
-	return ((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |
-		(a1->s6_addr32[1] ^ a2->s6_addr32[1]) |
-		(a1->s6_addr32[2] ^ a2->s6_addr32[2]) |
-		(a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0;
+  return ((__get_unaligned_cpu32(&a1->s6_addr32[0]) ^ 
+	   __get_unaligned_cpu32(&a2->s6_addr32[0])) |
+	  (__get_unaligned_cpu32(&a1->s6_addr32[1]) ^ 
+	   __get_unaligned_cpu32(&a2->s6_addr32[1])) |
+	  (__get_unaligned_cpu32(&a1->s6_addr32[2]) ^ 
+	   __get_unaligned_cpu32(&a2->s6_addr32[2])) |
+	  (__get_unaligned_cpu32(&a1->s6_addr32[3]) ^ 
+	   __get_unaligned_cpu32(&a2->s6_addr32[3]))) == 0;
 }
 
 static inline int __ipv6_prefix_equal(const __be32 *a1, const __be32 *a2,
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 22ef5f9..ba643f4 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -2834,7 +2834,7 @@ found:
 
 	p = *head;
 	th2 = tcp_hdr(p);
-	tcp_flag_word(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);
+	tcp_flag_word2(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);
 
 out_check_final:
 	flush = len < mss;
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index 54a0dc2..f4c13ee 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -52,7 +52,7 @@ int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
 {
 	int offset, offset_seq;
 	int hlen;
-
+	__be32 *pspi, *pseq;
 	switch (nexthdr) {
 	case IPPROTO_AH:
 		hlen = sizeof(struct ip_auth_hdr);
@@ -77,8 +77,10 @@ int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)
 	if (!pskb_may_pull(skb, hlen))
 		return -EINVAL;
 
-	*spi = *(__be32*)(skb_transport_header(skb) + offset);
-	*seq = *(__be32*)(skb_transport_header(skb) + offset_seq);
+	pspi = (__be32*)(skb_transport_header(skb) + offset);
+	pseq = (__be32*)(skb_transport_header(skb) + offset_seq);
+	*spi = __get_unaligned_cpu32(pspi);
+	*seq = __get_unaligned_cpu32(pseq);
 	return 0;
 }
 
-- 
1.7.5.4

